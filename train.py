import torch.cuda

from ultralytics import YOLO

# TODO:
#  BASE MODEL:
#       1. Запустить модель yolov10n на Каждом из датасетов с определенными настройками как в статьях.
#  SFS-CNet:
#       1. Добавить реализации компонентов из SFS-CNet
#       2. Сконфигурировать модель из реализованных компонентов
#       3. Запустить модель на Каждом из датасетов с определенными настройками как в статьях.
#  YOLOX +:
#       1. Добавить вычисление кастомной метрики
#       2. Скорректировать вычисление loss
#       3. Запустить модель на Каждом из датасетов с определенными настройками как в статьях.
def main():
    # Загрузите модель YOLOv10
    model = YOLO('ultralytics/cfg/models/v10/yolov10n_sfc_conv2.yaml', task='detect')  # или 'yolov10s.pt', 'yolov10m.pt' и т.д.
    device = 0 if torch.cuda.is_available() else 'cpu'

    # Обучите модель
    model.train(
        data='datasets/HRSID/hrsid.yaml',
        epochs=300,
        imgsz=640,
        batch=16,
        device=device,  # Укажите GPU, если доступен
        patience=50,    # Количество эпох без улучшений для остановки обучения
        pretrained=False,   # Определяет, следует ли начинать обучение с предварительно подготовленной модели
        optimizer='SGD',
        lr0=0.01,   # Начальная скорость обучения (т.е. SGD=1E-2, Adam=1E-3)
        lrf=0.01,   # Конечная скорость обучения как часть начальной скорости = (lr0 * lrf)
        seed=0, # Устанавливает случайное начальное значение для обучения, обеспечивая воспроизводимость результатов
        momentum=0.937,
        weight_decay=0.0005, # L2 regularization term

        # Настройка сохранения
        project='runs/training/HRSID',  # Основная папка для экспериментов
        name='yolov10n_sfs_conv2_silu_300epoch',  # Имя подпапки для конкретного запуска
        exist_ok=False,  # Продолжить обучение в существующей папке
        plots=True,  # Включить графики обучения

        # Аугментации
        auto_augment=None,
        hsv_h=0.015,    # Позволяет регулировать оттенок изображения на малую долю цветового круга, внося разнообразие в цветовую гамму.
        hsv_s=0.7,  # Немного изменяет насыщенность изображения, влияя на интенсивность цветов.
        hsv_v=0.4,  # Изменяет значение (яркость) изображения на незначительную величину
        degrees=0,  # Произвольный поворот изображения в заданном диапазоне градусов
        translate=0.1,  # Преобразует изображение по горизонтали и вертикали на долю размера изображения???
        scale=0.5,  # Масштабирует изображение
        fliplr=0.5, # Переворачивает изображение слева направо с заданной вероятностью
        mosaic=0.25, # Объединяет четыре обучающих изображения в одно, имитируя различные композиции сцен и взаимодействие объектов.
        close_mosaic=10,  # Отключает аугментацию mosaic за 10 эпох до окончания обучения
        cutmix=0.1    # Объединяет фрагменты двух изображений, создавая частичное смешение при сохранении четких областей.
    )


if __name__ == '__main__':
    main()